.. _implementation:

Physical implementation
***********************

Synthesis
---------

Most of the code generated by TMRG tool is redundant, which means that from a 
synthesizer point of view it can be removed. Of course, this behavior is
undesirable. The TMRG can generate a set of constrains for you  which will 
force Design Compiler (which is now part of the RTL Compiler) not to discard
the redundant logic. 
To generate the file, you have to add an option while you are executing tmrg:

.. code-block:: bash

    $ tmrg --generate_sdc --sdc_headers comb06.v

As a result, a file ``comb06TMR.sdc`` will be generated. The file is a proper
SDC file which can be directly loaded from the RC. For the example above it 
can look like this:

.. code-block:: bash

    set sdc_version 1.3
    set_dont_touch /designs/comb06TMR/nets/combLogicA
    set_dont_touch /designs/comb06TMR/nets/combLogicB
    set_dont_touch /designs/comb06TMR/nets/combLogicC
    set_dont_touch /designs/comb06TMR/nets/combLogic
    set_dont_touch /designs/comb06TMR/nets/inA
    set_dont_touch /designs/comb06TMR/nets/inB
    set_dont_touch /designs/comb06TMR/nets/inC
    set_dont_touch /designs/comb06TMR/nets/in

The file contains a minimum set (to our knowledge) of rules which from one side
ensures that the triplication is not optimized out and from the other side does not
prevent DC from optimizing the actual logic. To load the file in RC you can input:

.. code-block:: bash

    read_sdc comb06TMR.sdc

If you do not want to specify command line options every time, you can also 
put options in the section ``tmrg`` in the configuration file, as shown below:

.. code-block:: text

    [tmrg]
    # should SDC file for DC be generated? [true/false]
    generate_sdc = true
    # should headers of SDC file be added ? [true/false]
    sdc_headers = true

RTL Compiler / Genus trick & tips
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It happens that one wants to instantiate some cells in the Verilog netlist manually, f.e.:

.. code-block:: verilog

    [..]
    INVD1 instName(.I(myInput), .ZN(myOutput));
    [..]

To prevent RC from 'optimizing' it, one can use SDC constraint (usually in ``syn/sdc/constraint.sdc`` in HEP flow), preventing
the tool from touching any INVD1 cells:

.. code-block:: tcl

   set_dont_touch INVD1

The problem can be also tackled from another perspective. In the RC script (usually ``syn/scripts/init.tcl``) 
one can set ``preserve`` attribute for given instance:


.. code-block:: tcl

    set_attribute preserve true /path/instName


Place & Route
-------------

To ensure that the triplication effort makes sense, one has to ensure that
the triplicated instances of the same element are not placed too close to each other.
Such a physical proximity may lead to a situation, where one particle traversing the ASIC is
able to deposit energy along several logic cells at the same time causing multiple bit upsets. 
Such an error can not be detected and then leads to malfunctioning of the design. 

In the real design, there are majority voters before(or after) flip-flops. 
From the P&R optimization point of view, in order to keep the routing short, 
instances of triplicated flip-flops should be placed relatively close together. 

There is a PLAG (Placement Generatror) tool in the TMRG toolset. 
The tool operate on a final netlist and can assign registers to a specific ``Instances Group``. 
In order to declare which cells (registers) should be assigned to which placement groups, one has to
create a configuration file, for example ``plag.cfg``. The file has to contain a group called ``[plag]`` and 
one attribute ``cells`` which contains a space-separated list of cells to be placed. An example file is shown below:

.. code-block:: bash

    [plag]
    cells= DFQD1

An example usage of the tool for the netlist generated for the example ``fsm02`` can look like:

.. code-block:: bash

   plag --lib libs/tcbn65lp.v fsm02_r2g.v 

Alternatively the cell list can be specified as a command line parameter (``--cells``).
As a result a tcl script ``tmrPlace.tcl`` is generated. In this example the file will
look like:

.. code-block:: tcl

   addInstToInstGroup tmrGroupA {fsm02TMR/stateA_reg}
   addInstToInstGroup tmrGroupB {fsm02TMR/stateB_reg}
   addInstToInstGroup tmrGroupC {fsm02TMR/stateC_reg}

The designer should create specific regions where various groups of cells can be
placed, then he can source the generated script:

.. code-block:: tcl

  createInstGroup tmrGroupA -region 0 0 10 10
  createInstGroup tmrGroupB -region 10 0 20 10
  createInstGroup tmrGroupB -region 20 0 30 10
  source tmrPlace.tcl

.. Moreover, the tool is capable of calculating distances between triplicated
.. flip-flops and making histogram of these.

