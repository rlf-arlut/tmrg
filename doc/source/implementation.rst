.. _implementation:

Physical implementation
***********************

Synthesis
---------

Most of the code generated by TMRG tool is redundant, which means that from 
synthesizer point of view it can be removed. Of course, this behavior is
undesirable. The TMRG can generate for you a set of constrains which will 
force Design Compiler (which is now part of RTL Compiler) not to throw away
the redundant logic. 
To generate the file you have to:

.. code-block:: bash

    $ tmrg --generate_sdc --sdc_headers comb06.v

As a result, a file ``comb06TMR.sdc`` will be generated. The file is a proper
SDC file which can be directly loaded from the RC. For the example above it 
can look like

.. code-block:: bash

    set sdc_version 1.3
    set_dont_touch majorityVoter
    set_dont_touch fanout
    set_dont_touch /designs/comb06TMR/nets/combLogicA
    set_dont_touch /designs/comb06TMR/nets/combLogicB
    set_dont_touch /designs/comb06TMR/nets/combLogicC
    set_dont_touch /designs/comb06TMR/nets/combLogic
    set_dont_touch /designs/comb06TMR/nets/inA
    set_dont_touch /designs/comb06TMR/nets/inB
    set_dont_touch /designs/comb06TMR/nets/inC
    set_dont_touch /designs/comb06TMR/nets/in

The file contains minimum set (to our knowledge) of rules which from one side
ensures that the triplication is not optimized and from the other side does not
prevent DC from optimizing the actual logic. To load the file in RC you can:

.. code-block:: bash

    read_sdc comb06TMR.sd

If you do not want to specify command line options every time, you can also 
put options in the section ``tmrg`` in the configuration file, s as shown below:

.. code-block:: text

    [tmrg]
    # should SDC file for DC be generated? [true/false]
    generate_sdc = true
    # should headers of SDC file be added ? [true/false]
    sdc_headers = true


Place & Route
-------------

To ensure that triplication effort makes sens, one has to ensure that
the triplicated instances of the same element are not placed to close to each other.
Such a physical proximity may lead to situation, where one particle traversing the ASIC is
able to deposit energy along several logic cells at the same time causing multiple bit upsets. 
Such an error can not be detected and then leads to malfunctioning of the design. 

In the real design, there are majority voters before(or after) flip-flops. 
From the P&R optimization point of view, in order to keep routing short, the
instances of triplicated flip-flops should be placed relatively close together. 

If designer creates several specific regions where to put various groups of flip-flops:

.. code-block:: tcl

  createInstGroup tmrGroupA -region 0 0 10 10
  createInstGroup tmrGroupB -region 10 0 20 10
  createInstGroup tmrGroupB -region 20 0 30 10

the TMRG tool can generate a file which will assign flip-flops to proper groups:

.. code-block:: tcl

  addInstToInstGroup tmrGroupA {GBLDDIGITALTMR/MB/MC1/memA_reg[0]}
  addInstToInstGroup tmrGroupB {GBLDDIGITALTMR/MB/MC1/memB_reg[0]}
  addInstToInstGroup tmrGroupC {GBLDDIGITALTMR/MB/MC1/memC_reg[0]}

  addInstToInstGroup tmrGroupA {GBLDDIGITALTMR/MB/MC1/memA_reg[1]}
  addInstToInstGroup tmrGroupB {GBLDDIGITALTMR/MB/MC1/memB_reg[1]}
  addInstToInstGroup tmrGroupC {GBLDDIGITALTMR/MB/MC1/memC_reg[1]}

Moreover, the tool is capable of calculating distances between triplicated
flip-flops and making histogram of these.

