.. _implementation:

Physical implementation
***********************

Synthesis
---------

Most of the code generated by TMRG tool is redundant, which means that from a 
synthesizer point of view it can be removed. Of course, this behavior is
undesirable. There are two different ways of instructing the synthesis tool to keep
this logic. 

Constraining the design in Genus
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

After elaboration of the triplicated verilog source code, the synthesis tool itself
can be used to constrain the design before synthesis. All majority voters and fanouts
need to have their input and output nets set to ``do_not_touch``. This can be achieved
by running the following TCL snippet between calls to ``elaborate`` and ``syn_generic``:

.. code-block:: tcl

    set cells_voter [get_cells -quiet *Voter*]
    set cells_fanout [get_cells -quiet *Fanout*]

    set pins_voter [get_pins -of_objects $cells_voter -filter pin_name=~inA*||pin_name=~inB*||pin_name=~inC*||pin_name=~out*]
    set pins_fanout [get_pins -of_objects $cells_fanout -filter pin_name=~in*||pin_name=~outA*||pin_name=~outB*||pin_name=~outC*]

    set nets_donttouch [get_nets -segments -of_objects [concat $pins_voter $pins_fanout]]
    set_db $nets_donttouch .dont_touch true


After synthesis has finished, these constraints need to be removed again, so during place and route
buffers can be placed on these nets when required. This can be achieved by running the following tcl
command after ``syn_opt`` but before writing the constraints file for place and route.

.. code-block:: tcl
    set_db -quiet [get_db nets -if {.dont_touch == true}] .dont_touch false

SDC file generated by TMRG
^^^^^^^^^^^^^^^^^^^^^^^^^^

TMRG can alternatively generate a set of SDC constrains for you which will
force synthesis  tools not to merge the redundant logic.
**However, this approach is known to generate incomplete constraints
when using the verilog ``generate`` statement. Always check the generated
constraint file very carefully.**

To generate the file, you have to add an option while you are executing tmrg:

.. code-block:: bash

    $ tmrg --generate_sdc --sdc_headers comb06.v

As a result, a file ``comb06TMR.sdc`` will be generated. The file is a proper
SDC file which can be directly loaded from the RC. For the example above it 
can look like this:

.. code-block:: bash

    set sdc_version 1.3
    set_dont_touch /designs/comb06TMR/nets/combLogicA
    set_dont_touch /designs/comb06TMR/nets/combLogicB
    set_dont_touch /designs/comb06TMR/nets/combLogicC
    set_dont_touch /designs/comb06TMR/nets/combLogic
    set_dont_touch /designs/comb06TMR/nets/inA
    set_dont_touch /designs/comb06TMR/nets/inB
    set_dont_touch /designs/comb06TMR/nets/inC
    set_dont_touch /designs/comb06TMR/nets/in

The file contains a minimum set (to our knowledge) of rules which from one side
ensures that the triplication is not optimized out and from the other side does not
prevent DC from optimizing the actual logic. To load the file in RC you can input:

.. code-block:: bash

    read_sdc comb06TMR.sdc

If you do not want to specify command line options every time, you can also 
put options in the section ``tmrg`` in the configuration file, as shown below:

.. code-block:: text

    [tmrg]
    # should SDC file for DC be generated? [true/false]
    generate_sdc = true
    # should headers of SDC file be added ? [true/false]
    sdc_headers = true

For place and route to complete correctly after this step, all the ``set_dont_touch``
constraints will have to be removed from the constraints file created by synthesis. This
can be achieved using the TCL snippet shown in the previous section.

RTL Compiler / Genus trick & tips
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It happens that one wants to instantiate some cells in the Verilog netlist manually, f.e.:

.. code-block:: verilog

    [..]
    INVD1 instName(.I(myInput), .ZN(myOutput));
    [..]

To prevent RC from 'optimizing' it, one can use SDC constraint (usually in ``syn/sdc/constraint.sdc`` in HEP flow), preventing
the tool from touching any INVD1 cells:

.. code-block:: tcl

   set_dont_touch INVD1

The problem can be also tackled from another perspective. In the RC script (usually ``syn/scripts/init.tcl``) 
one can set ``preserve`` attribute for given instance:


.. code-block:: tcl

    set_attribute preserve true /path/instName


Place & Route
-------------

To ensure that the triplication effort makes sense, one has to ensure that
the triplicated instances of the same element are not placed too close to each other.
Such a physical proximity may lead to a situation, where one particle traversing the ASIC is
able to deposit energy along several logic cells at the same time causing multiple bit upsets. 
Such an error can not be detected and then leads to malfunctioning of the design. 

In the real design, there are majority voters before(or after) flip-flops. 
From the P&R optimization point of view, in order to keep the routing short, 
instances of triplicated flip-flops should be placed relatively close together. 

There is a PLAG (Placement Generatror) tool in the TMRG toolset. 
The tool operate on a final netlist and can assign registers to a specific ``Instances Group``. 
In order to declare which cells (registers) should be assigned to which placement groups, one has to
create a configuration file, for example ``plag.cfg``. The file has to contain a group called ``[plag]`` and 
one attribute ``cells`` which contains a space-separated list of cells to be placed. An example file is shown below:

.. code-block:: bash

    [plag]
    cells= DFQD1

An example usage of the tool for the netlist generated for the example ``fsm02`` can look like:

.. code-block:: bash

   plag --lib libs/tcbn65lp.v fsm02_r2g.v 

Alternatively the cell list can be specified as a command line parameter (``--cells``).
As a result a tcl script ``tmrPlace.tcl`` is generated. In this example the file will
look like:

.. code-block:: tcl

   addInstToInstGroup tmrGroupA {fsm02TMR/stateA_reg}
   addInstToInstGroup tmrGroupB {fsm02TMR/stateB_reg}
   addInstToInstGroup tmrGroupC {fsm02TMR/stateC_reg}

The designer should create specific regions where various groups of cells can be
placed, then he can source the generated script:

.. code-block:: tcl

  createInstGroup tmrGroupA -region 0 0 10 10
  createInstGroup tmrGroupB -region 10 0 20 10
  createInstGroup tmrGroupB -region 20 0 30 10
  source tmrPlace.tcl

.. Moreover, the tool is capable of calculating distances between triplicated
.. flip-flops and making histogram of these.

In more recent versions of P&R tools, a different approach can be followed to ensure proper spacing of
triplicated flip-flops. ``Instace Spacing Groups`` can be used to constrain the minimum distance to be
kept between a specified set of instances. For each set of triplicated flip-flops, one instance spacing
group needs to be created and the placer needs to be instructed to respect these spacing rules.
The following script can be used to create a group for all triplicated flip-flops in a design:

.. code-block:: tcl

  set instance_spacing 15

  set A_regs [get_db [get_db insts -if {.name == "*A_reg*"}] .name]
  set B_regs [string map {A_reg B_reg} $A_regs]
  set C_regs [string map {A_reg C_reg} $A_regs]

  foreach A_reg $A_regs B_reg $B_regs C_reg $C_regs {
    create_inst_space_group \
      -group_name $A_reg \
      -inst "$A_reg $B_reg $C_reg" \
      -spacing_x $instance_spacing \
      -spacing_y $instance_spacing
  }

  set_db place_detail_check_inst_space_group true

Violations of constraints can be reported using the ``check_place`` command. The command 
``report_inst_space_group`` is available to report all the groups that were created.


