.. _implementation:

Physical implementation
***********************

Synthesis
---------

Most of the code generated by TMRG tool is redundant, which means that from 
synthesizer point of view it can be removed. Of course, this behavior is
undesirable. The TMRG can generate for you a set of constrains which will 
force Design Compiler (which is now part of RTL Compiler) not to throw away
the redundant logic. 
To generate the file you have add an option while you are executing tmrg:

.. code-block:: bash

    $ tmrg --generate_sdc --sdc_headers comb06.v

As a result, a file ``comb06TMR.sdc`` will be generated. The file is a proper
SDC file which can be directly loaded from the RC. For the example above it 
can look like

.. code-block:: bash

    set sdc_version 1.3
    set_dont_touch majorityVoter
    set_dont_touch fanout
    set_dont_touch /designs/comb06TMR/nets/combLogicA
    set_dont_touch /designs/comb06TMR/nets/combLogicB
    set_dont_touch /designs/comb06TMR/nets/combLogicC
    set_dont_touch /designs/comb06TMR/nets/combLogic
    set_dont_touch /designs/comb06TMR/nets/inA
    set_dont_touch /designs/comb06TMR/nets/inB
    set_dont_touch /designs/comb06TMR/nets/inC
    set_dont_touch /designs/comb06TMR/nets/in

The file contains minimum set (to our knowledge) of rules which from one side
ensures that the triplication is not optimized out and from the other side does not
prevent DC from optimizing the actual logic. To load the file in RC you can:

.. code-block:: bash

    read_sdc comb06TMR.sd

If you do not want to specify command line options every time, you can also 
put options in the section ``tmrg`` in the configuration file, as shown below:

.. code-block:: text

    [tmrg]
    # should SDC file for DC be generated? [true/false]
    generate_sdc = true
    # should headers of SDC file be added ? [true/false]
    sdc_headers = true


Place & Route
-------------

To ensure that triplication effort makes sens, one has to ensure that
the triplicated instances of the same element are not placed to close to each other.
Such a physical proximity may lead to situation, where one particle traversing the ASIC is
able to deposit energy along several logic cells at the same time causing multiple bit upsets. 
Such an error can not be detected and then leads to malfunctioning of the design. 

In the real design, there are majority voters before(or after) flip-flops. 
From the P&R optimization point of view, in order to keep routing short, the
instances of triplicated flip-flops should be placed relatively close together. 

There is a PLAG (Placement Generatror) tool in the TMRG toolset. 
The tool operate on a final netlist and can assign registers to a specific ``Instances Group``. 
In order to declare which cells (registers) should be assigned to placement groups, one has to
create a configuration file, for example ``plag.cfg``. The file has to contain a group called ``[plag]`` and 
one attribute ``cells`` which contains a space separated list of cells to be placed. An example file is shown below:

.. code-block:: bash

    [plag]
    cells= DFQD1

An example usage of the tool for the netlist generated for the example ``fsm02`` can look like:

.. code-block:: bash

   plag --lib libs/tcbn65lp.v fsm02_r2g.v 

Alternatively the cell list can be specified as command line parameter (``--cells``).
As a result a tcl script ``tmrPlace.tcl`` is generated. In the considered example a file will
look like:

.. code-block:: tcl

   addInstToInstGroup tmrGroupA {fsm02TMR/stateA_reg}
   addInstToInstGroup tmrGroupB {fsm02TMR/stateB_reg}
   addInstToInstGroup tmrGroupC {fsm02TMR/stateC_reg}

Designer should create specific regions where to put various groups of cells
and then he can source the generated script:

.. code-block:: tcl

  createInstGroup tmrGroupA -region 0 0 10 10
  createInstGroup tmrGroupB -region 10 0 20 10
  createInstGroup tmrGroupB -region 20 0 30 10
  source tmrPlace.tcl

.. Moreover, the tool is capable of calculating distances between triplicated
.. flip-flops and making histogram of these.

